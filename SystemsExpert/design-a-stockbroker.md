# Design A Stockbroker
## System Requirements
This would be a platform like Robinhood, or TD Ameritrade Website.

This design would include only:
- Market orders on stocks (current price)
- The Place Trade API call and the response receive from it.
- SQL Table for customers balances
- Millions of customers
- Only on US
- Millions of trades / day
- High Availability (HA)
- The clients would be either mobile app or web app
- Callback function
  - To the Exchange's API
  - On Complete Trade Callback

This means that if a client makes a place order (buying or selling an stock) with the broker platform (website), the exchange needs to execute it as soon as possible. This is the case, regardless of the stock price.

There isn't any margin system either. So, the account balance is the source of truth for each client.

The system won't cover downloading documents, depositing funds, withrawing funds, etc. Just the core trading function of the platform.

The designs assumes that the customer has already deposited funds on the platform. And there is a SQL Table with the balance for each customer.

The platform is an intermediary between end users, and a central exchange. This means that the platform API would be exchanging information with the central exchange API.
- This API would take a callback function, in addtion to the info of the trade
- The callback would be executed when the trade completes on the exchange level. Either when the trade gets fulfilled or rejected.
- The exchange API also has HA. Meaning that it will always be executed once
- The callback is kind of a notification when the state of the trade changes

## Design Plan
We can design it on 3 or 4 steps, or categories:
1. Think what the API of the broker would look like. This means the signature of the inputs and outputs of the API Call
2. What the backend servers are going to look like. This means the servers that handles the Place Trade API Calls
3. The design for the part of the system that handles and executes trades. Which is the part of the system that communicates with the exchange

## API Call
When a client goes on the website / app, the need:
1. Pick the actual stock (Name of the stock)
2. Define if they want to buy or sell the stock (Type of the order)
3. Quantity, because one can buy or sell multiple stocks (Quantity of the stock)
4. The customer needs a registered account (A customerId)

The API could look like the following:
#### Trade:
- orderId: uuid,
- stockTicker: string,
- type: enum: ["buy", "sell"],
- quantity: integer,
- status: enum: ["placed", "executed", "filled", "rejected"],
- reason: string,
- createdAt: date

#### Trades:
- PlaceTrade(customerId: uuid, stockTicker: string, type: enum: ["buy", "sell"], quantity: integer) => Trade

The customerId is generated by authentication by the client, done securely.

The system doesn't conceives getting trade statuses or order statuses. Or even list of statuses. But still we want some kid of authentification for the order. Therefore, the function would return an struct, with the orderId.

The response also would have an status. Which represents an order that has been placed, but hasn't been executed or filled.

the "createdAt" property is the timestamp of when the order has been created.

## API Servers
All the API calls would modify the customer balance. In general terms:
- If a client sells an stock, it should increase the customer balance
- If a client buys an stock, it should decrease the customer balance

To complement the SQL Table for customer balances, the system would probably need to store the orders on SQL Table as well.

This makes the platform future proof, for adding functionality for listing trades and orders. That's why having all the trades and orders stored in a SQL table would make sense. 

The table could look like this:
### trades 
- id INT // Primary key, Auto Incremented Integer or randomly generated String
- customer_id UUID_VALUE
- stock_ticker VARCHAR(6)
- type ENUM('buy', 'sell')
- quant INT
- status ENUM('placed', 'executed', 'filled', 'rejected')
- reason VARCHAR(100) // A human readable reason of why a trade was rejected or filled
- c_at DATE

### balances
- id INT // Primary key, Auto Incremented Integer or randomly generated String
- customer_id UUID_VALUE
- amount FLOAT
- last_modified DATE


## Trade Execution
Placing trades is a very taxing operation to the machine, because of the amount that are being handled every second. 

The server doesn't need any type of caching. Because it follows a Queue / FIFO structure, in which the firt trade that gets in is also the first that gets out and executed.

The Load Balancer (LB) could use a Round Robin approach. Because we don't care which client's request gets forwarded to which server.

The only two important things when executing a trade are:
- The customer has enough money on the exchange
- The orders gets forwarded in order, because the market orders get executed regardless of the price

The tables gets updated after the API has already talked to the exchange.

As the API Servers handle too much operations, we would need to add another layer of servers to making the API Request on itself. These would be called "Workers". 

The "Workers" would make: 
- Calls to the API of the exchange,
- Wait for responses from it,
- Update the SQL Tables

As we are using a Round-Robin LB Approach, there could be 2 different servers with trades from the same customer. This could get out of hand very quickly. Because two or more servers could try to make updates to the same customer registry at the same time.

This problem could be solved by using a "Publish / Subscribe Messaging System" in which specific trades by an specific customer / specific customers would be routed to a Messaging Service. For instance, at a special topic or channel for the customer or a set of customers. In which, the same customer would always be routed to the same topic.

The Workers Servers would then:
1. Subscribe to those topics / channels
2. Watch for new trades or notifications, or messages coming in
3. Grab the messages off the message queues
4. Then talking to the exchange



![stockbroker-design](./design-a-stockbroker.png)